<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <title>Solar 热力学 / MLP 温度曲线演示</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 24px auto;
      max-width: 960px;
      padding: 0 16px;
      color: #1f2933;
      background: #f7f9fb;
    }
    h1 {
      font-size: 1.8rem;
      margin-bottom: 0.5rem;
    }
    form {
      background: #fff;
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 8px 16px rgba(15, 23, 42, 0.08);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px 16px;
      align-items: end;
      margin-bottom: 20px;
    }
    label {
      display: flex;
      flex-direction: column;
      font-size: 0.9rem;
      gap: 6px;
      color: #3e4c59;
    }
    input {
      padding: 8px 10px;
      border: 1px solid #bcccdc;
      border-radius: 6px;
      font-size: 0.95rem;
      background: #f8fafc;
    }
    button {
      padding: 10px 14px;
      border: none;
      border-radius: 6px;
      background: #2563eb;
      color: #fff;
      font-size: 0.95rem;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    button:hover {
      background: #1d4ed8;
    }
    .plot-container {
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 12px 24px rgba(15, 23, 42, 0.08);
      padding: 18px;
      margin-bottom: 28px;
    }
    .hint {
      font-size: 0.85rem;
      color: #52606d;
      margin-bottom: 16px;
    }
    #status {
      margin-bottom: 12px;
      font-size: 0.9rem;
      color: #52606d;
    }
    #status.error {
      color: #b91c1c;
    }
  </style>
</head>
<body>
  <h1>Solar 热模型对比 Demo</h1>
  <p class="hint">
    输入 Solar 电压后点击"生成曲线"。热力学模型与 MLP 模型会分别绘制温度随时间变化的曲线，新的输入会叠加在已有轨迹上以方便对比。<br>
    <strong>Solar电压范围：1.0-2.0V</strong>（实际数据范围：1.202-1.912V）<br>
    <strong>✅ MLP模型已修复并可在led.py中正常使用</strong>
  </p>

  <form id="control-form">
    <label>
      Solar 电压 (V)
      <input type="number" id="solar-input" step="0.001" min="1.0" max="2.0" value="1.45" required />
    </label>
    <label>
      模拟时长 (分钟)
      <input type="number" id="duration-input" min="1" max="720" value="480" />
    </label>
    <label>
      采样间隔 (秒)
      <input type="number" id="step-input" min="10" max="600" value="60" />
    </label>
    <label>
      起始环境温度 (°C)
      <input type="number" id="ambient-input" step="0.1" value="25" />
    </label>
    <button type="submit">生成曲线</button>
  </form>

  <div id="status" class="hint"></div>

  <div class="plot-container">
    <h2>热力学模型曲线</h2>
    <div id="thermal-chart"></div>
  </div>

  <div class="plot-container">
    <h2>MLP 模型曲线（含热模型基线）</h2>
    <p class="hint">当前页面在浏览器侧对 MLP 模型进行了近似残差补偿，仅用于交互演示。✅ 正式仿真可使用 Python 版本的 MLP 模型（已在 led.py 中修复）。</p>
    <div id="mlp-chart"></div>
  </div>

  <script>
    const SOLAR_THRESHOLD = 1.4;
    let heatingParams = null;
    let coolingParams = null;
    const thermalTraces = [];
    const mlpTraces = [];
    let sampleCounter = 1;

    async function loadParameters() {
      // 使用最新训练得到的模型参数 (2024年最新版本)
      heatingParams = {
        "model_type": "Pure Thermodynamic Model - Heating Phase",
        "formula": "ΔT(t) = K1(a1) × (1 - exp(-t/τ1)) + K2(a1) × (1 - exp(-t/τ2))",
        "solar_correction": "K1(a1) = K1_base × (1 + α_solar × (a1_val - 1.4))",
        "parameters": {
          "K1_base": 4.260038238599745,
          "tau1": 12.380527350353342,
          "K2_base": 4.807083871300749,
          "tau2": 192.93614028565025,
          "alpha_solar": 1.472768584503253
        },
        "a1_ref": 1.4
      };
      
      coolingParams = {
        "model_type": "Pure Thermodynamic Model - Cooling Phase",
        "formula": "ΔT(t) = K1(a1) × exp(-t/τ1) + K2(a1) × exp(-t/τ2)",
        "solar_correction": "K1(a1) = K1_base × (1 + α_solar × (a1_val - 1.4))",
        "parameters": {
          "K1_base": 3.3548987208209438,
          "tau1": 15.743670217895502,
          "K2_base": 5.318573214702604,
          "tau2": 168.80851716294282,
          "alpha_solar": 1.5105878683604992
        },
        "a1_ref": 1.4
      };
      
      setStatus('模型参数加载完成（使用2024年最新训练参数）。', false);
    }

    function setStatus(message, isError = false) {
      const box = document.getElementById('status');
      box.textContent = message;
      box.classList.toggle('error', isError);
    }

    function selectPhaseParams(isHeating) {
      return isHeating ? heatingParams : coolingParams;
    }

    function solarFactor(alpha, solarVal, a1Ref) {
      const factor = 1 + alpha * (solarVal - a1Ref);
      return Math.max(0, factor);
    }

    function thermalDelta(timeMinutes, solarVal, phaseParams, isHeating) {
      const params = phaseParams.parameters || {};
      const a1Ref = Number(phaseParams.a1_ref ?? 1.4);
      const alpha = Number(params.alpha_solar ?? 0);
      const factor = solarFactor(alpha, solarVal, a1Ref);

      const k1 = Number(params.K1_base ?? 0) * factor;
      const tau1 = Math.max(Number(params.tau1 ?? 1), 1e-6);
      const k2 = Number(params.K2_base ?? 0) * factor;
      const tau2 = Math.max(Number(params.tau2 ?? 1), 1e-6);

      const t = Math.max(0, timeMinutes);
      if (isHeating) {
        return k1 * (1 - Math.exp(-t / tau1)) + k2 * (1 - Math.exp(-t / tau2));
      }
      return k1 * Math.exp(-t / tau1) + k2 * Math.exp(-t / tau2);
    }

    function mlpDeltaApprox(timeMinutes, solarVal, phaseParams, isHeating) {
      const base = thermalDelta(timeMinutes, solarVal, phaseParams, isHeating);
      const residualStrength = 0.08;
      const normalizedSolar = solarVal - (phaseParams.a1_ref ?? 1.4);
      const fastDecay = Math.exp(-timeMinutes / 60);
      const slowDecay = Math.exp(-timeMinutes / 240);
      const residual = base * residualStrength * Math.tanh(normalizedSolar * 3) * (0.6 * fastDecay + 0.4 * slowDecay);
      return base + residual;
    }

    function buildTimeline(durationMinutes, stepSeconds) {
      const result = [];
      const stepMinutes = stepSeconds / 60;
      for (let t = 0; t <= durationMinutes + 1e-9; t += stepMinutes) {
        result.push(Number(t.toFixed(4)));
      }
      return result;
    }

    function computeTemperatureSeries({ solarVal, durationMinutes, stepSeconds, ambientTemp }) {
      const isHeating = solarVal > SOLAR_THRESHOLD;
      const phaseParams = selectPhaseParams(isHeating);
      const times = buildTimeline(durationMinutes, stepSeconds);
      const thermalTemps = [];
      const mlpTemps = [];

      for (const t of times) {
        const deltaThermal = thermalDelta(t, solarVal, phaseParams, isHeating);
        const deltaMlp = mlpDeltaApprox(t, solarVal, phaseParams, isHeating);
        const tempThermal = ambientTemp + deltaThermal;
        const tempMlp = ambientTemp + deltaMlp;
        thermalTemps.push(Number(tempThermal.toFixed(3)));
        mlpTemps.push(Number(tempMlp.toFixed(3)));
      }

      return { times, thermalTemps, mlpTemps, isHeating };
    }

    function addTrace({ times, thermalTemps, mlpTemps, solarVal, isHeating, ambientTemp }) {
      const phaseLabel = isHeating ? '升温' : '降温';
      const label = `Solar ${solarVal.toFixed(3)} V · ${phaseLabel} #${sampleCounter}`;
      thermalTraces.push({
        x: times,
        y: thermalTemps,
        mode: 'lines',
        name: label,
        hovertemplate: 't = %{x:.1f} min<br>温度 = %{y:.2f} °C<extra></extra>'
      });
      mlpTraces.push({
        x: times,
        y: mlpTemps,
        mode: 'lines',
        name: label,
        hovertemplate: 't = %{x:.1f} min<br>温度 = %{y:.2f} °C<extra></extra>'
      });
      sampleCounter += 1;

      const thermalLayout = {
        xaxis: { title: '时间 (min)' },
        yaxis: { title: '估算温度 (°C)' },
        legend: { orientation: 'h' },
        margin: { t: 20, r: 20, l: 50, b: 50 },
        template: 'plotly_white',
        shapes: [
          {
            type: 'line',
            x0: Math.min(...times),
            x1: Math.max(...times),
            y0: ambientTemp,
            y1: ambientTemp,
            line: { color: '#94a3b8', width: 1, dash: 'dot' }
          }
        ]
      };

      const mlpLayout = {
        xaxis: { title: '时间 (min)' },
        yaxis: { title: '估算温度 (°C)' },
        legend: { orientation: 'h' },
        margin: { t: 20, r: 20, l: 50, b: 50 },
        template: 'plotly_white',
        shapes: thermalLayout.shapes
      };

      Plotly.react('thermal-chart', thermalTraces, thermalLayout);
      Plotly.react('mlp-chart', mlpTraces, mlpLayout);
    }

    function handleSubmit(event) {
      event.preventDefault();
      if (!heatingParams || !coolingParams) {
        setStatus('模型参数尚未加载完成。', true);
        return;
      }

      const solarVal = Number(document.getElementById('solar-input').value);
      const durationMinutes = Number(document.getElementById('duration-input').value);
      const stepSeconds = Number(document.getElementById('step-input').value);
      const ambientTemp = Number(document.getElementById('ambient-input').value);

      if (!(solarVal >= 0) || !(durationMinutes > 0) || !(stepSeconds > 0)) {
        setStatus('请输入有效的太阳电压、时长与采样步长。', true);
        return;
      }

      const series = computeTemperatureSeries({ solarVal, durationMinutes, stepSeconds, ambientTemp });
      addTrace({ ...series, solarVal, ambientTemp });

      const phaseLabel = series.isHeating ? '升温阶段' : '降温阶段';
      setStatus(`已添加 Solar=${solarVal.toFixed(3)} V 的曲线 (${phaseLabel})。`);
    }

    async function init() {
      Plotly.newPlot('thermal-chart', [], { template: 'plotly_white' });
      Plotly.newPlot('mlp-chart', [], { template: 'plotly_white' });
      try {
        await loadParameters();
      } catch (err) {
        console.error(err);
      }
      document.getElementById('control-form').addEventListener('submit', handleSubmit);
      setStatus('等待输入…');
    }

    init();
  </script>
</body>
</html>
