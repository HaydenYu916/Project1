from __future__ import annotations

import math
from typing import Tuple
import matplotlib.pyplot as plt


def _clip(x: float, lo: float, hi: float) -> float:
    """辅助函数：将数值限制在指定范围内"""
    return max(lo, min(x, hi))


class LEDSystem:
    """
    LED照明系统类，包含一阶热模型
    
    该类封装了LED系统的物理参数和动态状态，允许对系统行为进行时间仿真。
    主要用于农业光照控制中的LED热效应建模。
    """

    def __init__(
        self,
        base_ambient_temp: float = 23.0,
        max_ppfd: float = 600.0,
        max_power: float = 86.4,
        thermal_resistance: float = 0.05,
        thermal_mass: float = 150.0,
        initial_temp: float | None = None,
    ):
        """
        初始化LED系统物理参数
        
        Args:
            base_ambient_temp: 环境基准温度(°C)，LED关闭时的环境温度
            max_ppfd: 100% PWM时的最大光合光子通量密度(μmol/m²/s)
            max_power: 100% PWM时的最大电功率消耗(W)
            thermal_resistance: 热阻(K/W)，从LED散热器到环境的热阻
            thermal_mass: 热容(J/°C)，决定系统温度变化快慢
            initial_temp: 系统初始温度(°C)，如果为None则使用环境基准温度
        """
        self.base_ambient_temp = base_ambient_temp  # 环境基准温度
        self.max_ppfd = max_ppfd                    # 最大PPFD
        self.max_power = max_power                  # 最大功率
        self.thermal_resistance = thermal_resistance # 热阻
        self.thermal_mass = thermal_mass            # 热容

        # 派生参数：热时间常数(秒) = 热阻 × 热容
        self.time_constant_s = self.thermal_resistance * self.thermal_mass

        # 状态变量：当前环境温度
        self.ambient_temp = (
            initial_temp if initial_temp is not None else self.base_ambient_temp
        )

    def step(self, pwm_percent: float, dt: float) -> Tuple[float, float, float, float]:
        """
        仿真LED系统的一个时间步长
        
        该方法更新系统内部的温度状态，模拟LED在给定PWM下的行为。
        
        Args:
            pwm_percent: LED的PWM控制信号(0-100)
            dt: 时间步长(秒)
            
        Returns:
            包含以下值的元组:
            - ppfd: 产生的PPFD(μmol/m²/s)
            - new_ambient_temp: 更新后的环境温度(°C)
            - power: 电功率消耗(W)
            - efficiency: 光转换效率估计值
        """
        if not (math.isfinite(pwm_percent) and math.isfinite(dt)):
            raise ValueError("pwm_percent和dt必须是有限实数")
        if dt <= 0:
            raise ValueError("dt必须为正数")

        # 将PWM百分比转换为0-1的分数
        pwm_fraction = _clip(pwm_percent / 100.0, 0.0, 1.0)

        # PPFD输出（与PWM线性相关）
        ppfd = self.max_ppfd * pwm_fraction

        # LED光效模型（高功率时略有下降）
        efficiency = 0.8 + 0.2 * math.exp(-2.0 * pwm_fraction)
        efficiency = _clip(efficiency, 1e-3, 1.0)

        # 功率计算和发热
        power = (self.max_power * pwm_fraction) / efficiency
        heat_power = power * (1.0 - efficiency)  # 发热功率

        # 目标温度（如果PWM保持恒定，系统将达到的温度）
        target_temp = self.base_ambient_temp + heat_power * self.thermal_resistance

        # 一阶热动态：温度变化
        # 使用更精确的离散时间更新公式
        tau = max(self.time_constant_s, 1e-6)
        alpha = 1.0 - math.exp(-dt / tau)  # 时间常数系数

        # 更新环境温度
        self.ambient_temp += alpha * (target_temp - self.ambient_temp)

        return float(ppfd), self.ambient_temp, float(power), float(efficiency)

    def steady_state(self, pwm_percent: float) -> Tuple[float, float, float, float]:
        """
        计算给定PWM百分比下的稳态值
        
        此方法不会改变系统的内部状态，仅用于计算稳态。
        
        Args:
            pwm_percent: LED的PWM控制信号(0-100)
            
        Returns:
            包含稳态值的元组:
            - ppfd: PPFD(μmol/m²/s)
            - final_ambient_temp: 最终环境温度(°C)
            - power: 功率消耗(W)
            - efficiency: 光转换效率
        """
        pwm_fraction = _clip(float(pwm_percent) / 100.0, 0.0, 1.0)

        # 稳态PPFD输出
        ppfd = self.max_ppfd * pwm_fraction

        # 稳态光效
        efficiency = 0.8 + 0.2 * math.exp(-2.0 * pwm_fraction)
        efficiency = _clip(efficiency, 1e-3, 1.0)

        # 稳态功率和发热
        power = (self.max_power * pwm_fraction) / efficiency
        heat_power = power * (1.0 - efficiency)

        # 稳态温度
        final_ambient_temp = (
            self.base_ambient_temp + heat_power * self.thermal_resistance
        )

        return float(ppfd), float(final_ambient_temp), float(power), float(efficiency)

    def reset(self):
        """将系统温度重置为环境基准温度"""
        self.ambient_temp = self.base_ambient_temp


# ---------------------------
# 简单演示程序
# ---------------------------
def run_led_on_off_example() -> None:
    """演示LED系统开关循环的仿真过程"""

    # 创建LED系统实例
    led_system = LEDSystem(
        base_ambient_temp=23.0,    # 环境基准温度23°C
        max_ppfd=600.0,           # 最大PPFD 600 μmol/m²/s
        max_power=86.4,           # 最大功率86.4W
        thermal_resistance=0.05,   # 热阻0.05 K/W
        thermal_mass=150.0,        # 热容150 J/°C
    )
    dt = 1.0  # 时间步长1秒

    # 用于绘图的数据列表
    time_data, temp_data, ppfd_data, pwm_data = [], [], [], []
    now_t = 0

    print("重构版LED开关温度示例")
    print("=" * 50)
    print(f"环境基准温度: {led_system.base_ambient_temp}°C\n")

    # 阶段1: 75% PWM运行60秒
    print("阶段1: LED开启(75% PWM) - 加热过程")
    print("时间\tPWM\tPPFD\t温度\t温升")
    print("-" * 40)
    for t in range(60):
        ppfd, new_temp, _, _ = led_system.step(75.0, dt)
        time_data.append(now_t)
        temp_data.append(new_temp)
        ppfd_data.append(ppfd)
        pwm_data.append(75.0)
        now_t += dt
        if t % 10 == 0:
            temp_rise = new_temp - led_system.base_ambient_temp
            print(f"{t}s\t75%\t{ppfd:.0f}\t{new_temp:.1f}°C\t+{temp_rise:.1f}°C")

    print()

    # 阶段2: 0% PWM运行60秒
    print("阶段2: LED关闭(0% PWM) - 冷却过程")
    print("时间\tPWM\tPPFD\t温度\t与基准差值")
    print("-" * 45)
    for t in range(60):
        ppfd, new_temp, _, _ = led_system.step(0.0, dt)
        time_data.append(now_t)
        temp_data.append(new_temp)
        ppfd_data.append(ppfd)
        pwm_data.append(0.0)
        now_t += dt
        if t % 10 == 0:
            temp_diff = new_temp - led_system.base_ambient_temp
            print(f"{60+t}s\t0%\t{ppfd:.0f}\t{new_temp:.1f}°C\t{temp_diff:+.1f}°C")

    print()

    # 阶段3: 50% PWM运行30秒
    print("阶段3: LED再次开启(50% PWM) - 适度加热")
    print("时间\tPWM\tPPFD\t温度\t温升")
    print("-" * 40)
    for t in range(30):
        ppfd, new_temp, _, _ = led_system.step(50.0, dt)
        time_data.append(now_t)
        temp_data.append(new_temp)
        ppfd_data.append(ppfd)
        pwm_data.append(50.0)
        now_t += dt
        if t % 10 == 0:
            temp_rise = new_temp - led_system.base_ambient_temp
            print(f"{120+t}s\t50%\t{ppfd:.0f}\t{new_temp:.1f}°C\t+{temp_rise:.1f}°C")

    # 绘制结果
    plot_results(time_data, temp_data, ppfd_data, pwm_data, led_system.base_ambient_temp)


def plot_results(time_data, temp_data, ppfd_data, pwm_data, base_ambient):
    """绘制仿真结果图表"""
    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 8))
    fig.suptitle("LED开关加热和冷却示例", fontsize=14)

    # 温度曲线
    ax1.plot(time_data, temp_data, "r-", linewidth=2, label="环境温度")
    ax1.axhline(y=base_ambient, color="k", linestyle="--", alpha=0.5, label="基准环境温度")
    ax1.set_ylabel("温度 (°C)")
    ax1.set_title("温度响应")
    ax1.grid(True, alpha=0.3)
    ax1.legend()
    ax1.axvspan(0, 60, alpha=0.15, color="red", label="LED开启(75%)")
    ax1.axvspan(60, 120, alpha=0.15, color="blue", label="LED关闭(0%)")
    ax1.axvspan(120, 150, alpha=0.15, color="orange", label="LED开启(50%)")

    # PPFD曲线
    ax2.plot(time_data, ppfd_data, "g-", linewidth=2)
    ax2.set_ylabel("PPFD (μmol/m²/s)")
    ax2.set_title("光输出(PPFD)")
    ax2.grid(True, alpha=0.3)

    # PWM曲线
    ax3.plot(time_data, pwm_data, "b-", linewidth=2)
    ax3.set_ylabel("PWM (%)")
    ax3.set_xlabel("时间 (秒)")
    ax3.set_title("PWM控制信号")
    ax3.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    run_led_on_off_example()
